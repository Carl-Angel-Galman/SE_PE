\newpage
\section{Proposed Software Architecture}

% ==========================================================
\subsection{System Overview (Gesamtkontext)}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Overview.png}
  \caption{Gesamtüberblick: Systemkontext und Kommunikations-/Datenflüsse}
  \label{fig:overview_total}
\end{figure}

\subsubsection{Kurzbeschreibung}
Abbildung~\ref{fig:overview_total} zeigt den Gesamtkontext der Emergency-Stop-Funktion innerhalb des Truck-Systems. Die Distanzsensorik wird auf der Komponente 
\emph{Jetson Nano} verarbeitet, während die Hardware-I/O über die Truck-Knoten \emph{Master} und \emph{Slave} angebunden sind. Die Bedien- und Leitsoftware 
\emph{Mission Control} kommuniziert über WLAN mit dem System und ermöglicht die Fernsteuerung, insbesondere das Senden von Stop- und Fahrfreigabesignalen.

Für den Emergency Stop sind insbesondere die Eingaben über Taster oder Fernsteuerung sowie die Ansteuerung von Aktorik relevant, um Stop- oder Fahrfreigaben umzusetzen. 
Zusätzlich bilden die Distanzinformationen die Grundlage für die Berechnung der Time-To-Collision (TTC) und damit für softwarebasierte Stop-Entscheidungen.





% Zusätzlich sind die internen Knoten wie folgt gekoppelt:
% \begin{itemize}[leftmargin=*, itemsep=2pt]
%   \item \textbf{Arduino Mega ``Master'' $\leftrightarrow$ Arduino Mega ``Slave'':} Verbindung über \textbf{CAN}.
%   \item \textbf{Jetson AGX / Arduino Mega ``Master'' / WLAN-Modul:} Anbindung über internes \textbf{LAN} zum \emph{WLAN Client}.
% \end{itemize}

% Die Hardware-Anbindung ist wie folgt verteilt:
% \begin{itemize}[leftmargin=*, itemsep=2pt]
%   \item \textbf{Arduino Mega ``Master'':} \emph{Soft-Stop Schalter} sowie \emph{Lichter/Signalisierung} (z.\,B. Blinklicht).
%   \item \textbf{Jetson AGX:} Anbindung der \emph{zwei LiDAR-Sensoren}.
%   \item \textbf{Arduino Mega ``Slave'':} \emph{Pilz-Notknopf (Notaus)}.
% \end{itemize}

\subsubsection{Subsysteme und Schnittstellen von Emergency Stop}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/SubSystems.png}
  \caption{Gesamtüberblick: Systemkontext und Kommunikations-/Datenflüsse}
  \label{fig:subsystems_context}
\end{figure}

Abbildung~\ref{fig:subsystems_context} zeigt die für den Emergency Stop relevanten Subkomponenten 
sowie deren Schnittstellen und Datenflüsse.

Der \emph{TTC-Observer} verarbeitet die Distanzdaten und berechnet die Time-To-Collision (TTC). 
Auf Basis dieser Berechnung erzeugt er Stop- und Fahrfreigabeereignisse und übermittelt diese an den \emph{System State Manager}.

Das \emph{EnvironmentControl Interface} stellt die Anbindung an die Hardware dar. Es liest die 
Zustände der Not-Aus- und Soft-Stop-Taster aus und leitet diese an den \emph{System State Manager} 
weiter. Zusätzlich steuert es die Aktorik, insbesondere Warnleuchten und Soft-Stop-LEDs, basierend 
auf den vom System State Manager vorgegebenen Zuständen. Darüber hinaus stellt es die gemessene Distanz zur Verfügung.

Die \emph{DriveControlUnit} setzt die Stop- und Fahrfreigabeanforderungen um. Außerdem liefert sie 
die aktuelle Fahrzeuggeschwindigkeit, welche an den \emph{System State Manager} und den \emph{TTC-Observer} weitergegeben wird.

Der \emph{System State Manager} bildet die zentrale Steuereinheit des Emergency-Stop-Systems. Er 
verarbeitet alle eingehenden Ereignisse aus den Subsystemen, verwaltet die Zustände und steuert 
die Ausgabe von Stop- und Fahrfreigaben. Zudem koordiniert er die Interaktion zwischen den 
Subkomponenten und stellt sicher, dass sicherheitskritische Anforderungen konsistent umgesetzt werden.

Das \emph{Logging}-Modul protokolliert Zustandsänderungen sowie Fehlerereignisse und ermöglicht 
damit eine Nachvollziehbarkeit des Systemverhaltens.

\newpage

% ==========================================================
\subsection{Subsystem Decomposition und Klassendesign}

\subsubsection{Klassendiagramm (Übersicht)}
% Hinweis: Dieses Diagramm deckt die geforderte Klassensicht (Attribute + public Operations) ab.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Klassendiagramm_Übersicht.png}
  \caption{Klassendiagramm: Überblick über zentrale Klassen und Zustände}
  \label{fig:class_overview}
\end{figure}



Das Klassendiagramm in Abbildung~\ref{fig:class_diagram} gibt einen Überblick über die zentralen Klassen, deren Beziehungen sowie die Struktur der Zustandslogik des Emergency-Stop-Systems.

Die Architektur basiert auf einer klaren Trennung von Zuständigkeiten und einer 
Koordination durch den \emph{System State Manager}. Die Subkomponenten sind so gestaltet, dass 
sie ihre spezifischen Funktionen erfüllen, während der \emph{System State Manager} die Gesamtlogik und Synchronisation übernimmt.

Der System State Manager besitzt eine Referenz auf die Aktuelle Instanz der IState-Klasse. Die Klasse \emph{IState} 
ist eine Abstrakte Klasse und definiert die abstrakten Methoden \emph{onEntry}, \emph{onCyclic} und \emph{onExit}, die von den konkreten Zustandsklassen implementiert werden. 
Dadurch wird die Zustandsübergangskontrolle in einer zentralen und wiederverwendbaren Art und Weise realisiert.
Die Zustandswechsel werden mit einer \emph{State\_Table\_Entry} realisiert mittels der \emph{State\_Table\_Entry} Datenstruktur,
die die aktuelle State, das Event und die nächste State enthält. Wenn ein Event auftritt, überprüft der System State Manager
die \emph{State\_Table\_Entry}, um zu bestimmen, welcher Zustandsübergang ausgeführt werden soll udn ausgeführt werden darf. 

Diese Architektur ermöglicht eine klare Trennung der logik und eine einfache Erweiterbarkeit, da 
neue zustände oder Ereignisse hinzugefügt werden können, ohne die gesamte Logik zu verändern. Zudem wird die Wartbarkeit verbessert, da die Zustandslogik in klar definierten Klassen gekapselt ist.
Mit dem nachteil alle inputs und outputs müssen über den System State Manager laufen, was zu einem Engpass führen könnte, wenn die Anzahl der Ereignisse oder Zustände stark zunimmt. Es könnte auch zu einer erhöhten Komplexität führen, wenn viele Zustände und Übergänge vorhanden sind, da die State\_Table sehr groß und schwer zu verwalten sein könnte.
\subsubsection{Alternativen Software-Architektur}

Eine alternative Architektur könnte auf einem stärker ereignisgesteuerten Ansatz basieren, bei dem die Subkomponenten direkt auf Ereignisse reagieren und weniger zentral koordiniert werden. 
In diesem Fall könnte jede Subkomponente ihre eigenen Zustandsautomaten haben, die auf eingehende Ereignisse reagieren, ohne dass ein zentraler 
System State Manager die Gesamtlogik steuert. Dies könnte zu einer dezentraleren und möglicherweise flexibleren Architektur führen, aber auch zu einer erhöhten Komplexität bei der Synchronisation und Fehlerbehandlung.

Eine weitere Architektur könnte auf einem Service-basierten Ansatz basieren, bei dem jede Subkomponente als eigenständiger Service mit klar definierten Schnittstellen implementiert wird.
Diese Services könnten über ein Messaging-System kommunizieren, um Ereignisse und Daten auszutauschen. Dies könnte die Modularität und Skalierbarkeit erhöhen, aber auch die Latenz und Komplexität der Kommunikation erhöhen.

Insgesamt stellt das Klassendiagramm die Grundlage für die nachfolgende detaillierte Ausarbeitung dar und bildet die strukturelle Basis für die Implementierung der zustandsbasierten Steuerlogik.
\newpage
% Optional: wenn ihr die einzelnen Klassendiagramme später separat habt, hier weitere Platzhalter:
% \paragraph{Weitere Klassendiagramme (optional)}
% TODO: ggf. zusätzliche Klassendiagramme je Subsystem einfügen

% ==========================================================
\subsection{Hardware/Software Mapping (Deployment)}
\label{sec:deployment}

\subsubsection{Deployment Diagram}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Deployment.png}
  \caption{Zuordnung von Subkomponenten zur Hardware}
  \label{fig:deployment}
\end{figure}

\subsubsection{Zuordnung der Komponenten}
\begin{itemize}[leftmargin=*, itemsep=2pt]
  \item \textbf{Jetson AGX:} \emph{TTC-Observer}
  \item \textbf{Arduino Mega ``Master'':} \emph{EnvironmentControl Interface}
  \item \textbf{Arduino Mega ``Slave'':} \emph{Emergency Stop}, \emph{DriveControlUnit}, \emph{Logging}
\end{itemize}

\subsubsection{Begründung der Verteilung}
\begin{itemize}[leftmargin=*, itemsep=2pt]
  \item \textbf{Arduino Mega ``Slave'':} sicherheitskritische Funktionen + Logging lokal.
  \item \textbf{Arduino Mega ``Master'':} kapselt Hardware-I/O (Interface-Schicht).
  \item \textbf{Jetson AGX:} TTC-Auswertung (\emph{TTC-Observer}) und Weitergabe an Emergency Stop.
\end{itemize}

% ==========================================================
\subsection{Global Software Control}
Dieser Abschnitt beschreibt die Interaktion
zwischen dem \emph{Emergency Stop}-Subsystem und den restlichen Subsystemen.


\subsubsection{Sequence Diagram: TTC}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_TTC.png}
  \caption{Sequence Diagram: Interaktion TTC-Observer zu TTC Handler}
  \label{fig:seq_ttc}
\end{figure}

Die Abbildung \ref{fig:seq_ttc} zeigt die Interaktion 
zwischen dem \emph{Emergency Stop}-Subsystem und
dem \emph{TTC-Observer}-Subsystem. Der \emph{TTC-Observer}
besitzt nur Zugriff auf die Funktionen des \emph{TTC Handler},
welcher die Schnittstelle zum \emph{Emergency Stop} darstellt.
Der \emph{TTC Observer} kann drei verschiedene Funktionen,
basierend auf den berechneten Werten des TTC, aufrufen:
\begin{itemize}[leftmargin=*, itemsep=2pt]
  \item \textbf{stopRequest():} Stop-Anforderung, wenn der berechnete TTC-Wert in der Safety-Zone liegt.
  \item \textbf{haltRequest():} Verzögerungs-Anforderung, wenn der berechnete TTC-Wert in der Interventions-Zone liegt.
  \item \textbf{enableDriving():} Freigabe der Fahrfunktion, wenn der berechnete TTC-Wert in der Free-Zone liegt.
\end{itemize}
Ob eine dieser drei Funktionen aufgerufen wurde,
wird zyklisch von dem \emph{System State Manager}
überprüft, um diese Aktion entsprechend umzusetzen.
Dies geschieht alle 5ms, da es sich um eine sicherheitskritische Funktion handelt und somit eine schnelle Reaktionszeit gewährleistet sein muss.
Zur Überprüfung stellt der \emph{TTC Handler} drei Getter-Funktionen bereit, welche den aktuellen Status der drei Funktionen zurückliefern:
\begin{itemize}[leftmargin=*, itemsep=2pt]
  \item \textbf{getStopRequest()}
  \item \textbf{getHaltRequest()}
  \item \textbf{getEnableDriving()}
\end{itemize}
Der \emph{TTC-Observer} besorgt sich
die aktuelle Geschwindigkeit des Trucks
ebenfalls alle 5ms über die Funktion \textbf{getCurrentSpeed()} des \emph{TTC Handlers}.
Dies gewährleistet, dass die TTC-Werte immer angemesen aktuell sind.

% TODO: Beschriftung im Diagramm ist verwechselt und isButton Pressed Funktion nicht richtig Zeit auch 5ms
\subsubsection{Sequence Diagram: EnvironmentControl Interface}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_EnvironmentControl_Interface.png}
  \caption{Sequence Diagram: Abfragen von Button-States und Setzen von LEDs}
  \label{fig:seq_envctrl}
\end{figure}
Die Abbildung \ref{fig:seq_envctrl} zeigt die Interaktion zwischen dem \emph{Emergency Stop}-Subsystem und dem \emph{EnvironmentControl Interface}.
Der \emph{EnvironmentControl Interface} stellt Funktionen bereit, um die Zustände der Not-Aus- und Soft-Stop-Buttons abzufragen sowie die Signalisierung (z.\,B. LEDs) zu steuern.
Des Weiteren bietet es die Daten der Abstandsmessung der LiDAR-Sensoren an.
Der \emph{System State Manager} ruft zyklisch alle 5ms die Funktion \textbf{isButtonPressed()} auf, um die aktuellen Zustände der Buttons zu überprüfen.
Der \emph{Button Handler} reicht diese Anfragen an die entsprechenden
Schnittstellenfunktionen des \emph{EnvironmentControl Interface} weiter
und erhält die aktuellen Zustände der Not-Aus- und Soft-Stop-Buttons zurück.
Diese Informationen werden anschließend dem \emph{System State Manager} zur Verfügung gestellt, um die entsprechenden Aktionen (z.\,B. Stoppen des Fahrzeugs) zu steuern.

Die Interaktion mit den LEDs erfolgt über den
\emph{LED Handler}. Der \emph{System State Manager}
kann dessen Funktionen \textbf{blinkCyclic_WarningLight()}
und \textbf{toggle_SoftstopLED()} aufrufen, um die Signalisierung entsprechend der aktuellen Systemzustände zu steuern.
Das Warning-Light (Blinklicht) auf dem Fahrzeug wird aktiviert, wenn sich das System im Not-Aus-Zustand befindet, um eine visuelle Warnung anzuzeigen.
Die SoftstopLED bezieht sich auf die LED um den Soft-Stop-Button.
Die Schnittstelle zum \emph{EnvironmentControl Interface}
bietet die Funktion \textbf{setLEDState()}.
Im Falle des Blinklichts wird die LED zyklisch an- und ausgeschaltet, um das Blinken zu realisieren.

%TODO: Geschwindigkeisberechnung ergibt keinen Sinn

Die Abstraktion der Hardware-Interaktion ermöglicht einfache
Erweiterungen oder Anpassungen der Hardware, ohne dass die Hauptlogik des \emph{Emergency Stop}-Subsystems geändert werden muss.



\subsubsection{Sequence Diagram: Drive Control Unit}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_Drive_Controll_Unit.png}
  \caption{Sequence Diagram: Stop/Enable/Speed via Drive Controller Handler}
  \label{fig:seq_drive}
\end{figure}

%TODO: speed Control braucht Parameter
Die Abbildung \ref{fig:seq_drive} zeigt die Interaktion zwischen dem \emph{Emergency Stop}-Subsystem und der \emph{Drive Control Unit}.
Diese wird in dem \emph{Drive Controller Handler} abstrahiert.
Der \emph{System State Manager} sendet die Fahrtanweisungen
mithilfe der Funktionen \textbf{stopRequest()}, \textbf{enableDriving()} und \textbf{speedControl()}.
Diese Funktionen leitet der \emph{Drive Controller Handler} an die entsprechenden Schnittstellenfunktionen der \emph{Drive Control Unit} weiter, um die gewünschten Aktionen umzusetzen.
Die Abstraktion ermöglicht erneut einfache Änderungen an Software oder Hardware der Drive Control Unit, ohne dass die Hauptlogik des \emph{Emergency Stop}-Subsystems angepasst werden muss.

\subsubsection{Sequence Diagram: Logging}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_Sequenz_Logging.png}
  \caption{Sequence Diagram: Logging von StateChange, Error und Trace}
  \label{fig:seq_logging}
\end{figure}
%TODO: Loggen von Fehlern und State Changes braucht Parameter

Die Abbildung \ref{fig:seq_logging} zeigt die Interaktion zwischen dem \emph{Emergency Stop}-Subsystem und der \emph{Logging}-Komponente.
Der \emph{Logging Handler} stellt Funktionen bereit, um wichtige Ereignisse wie State Changes, Fehler und Trace-Informationen zu protokollieren.
Der \emph{System State Manager} ruft die entsprechenden Funktionen des \emph{Logging Handlers} auf, um diese relevante Informationen zu protokollieren.
Diese Funktionen sind:
\begin{itemize}
  \item \textbf{logStateChange()}: Protokolliert Änderungen im Systemzustand, z.\,B. Wechsel von "Initialization" zu "SoftStop".
  \item \textbf{logError()}: Protokolliert aufgetretene Fehler, z.\,B. Initialisierungsfehler.
  \item \textbf{traceFunctionCall()}: Protokolliert den Aufruf von Funktionen, z.\,B. Steuerung des Fahrzeugs.
\end{itemize}
Diese Funktionen erzeugen fertige Log- bzw Trace-Einträge, welche mit allen relevanten Informationen (wie Timestamp) versehen sind und anschließend von der \emph{Logging}-Komponente verarbeitet und gespeichert werden.
% ==========================================================
\subsection{Boundary Conditions}

\subsubsection{Sequence Diagram: Start-up}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_Startup.png}
  \caption{Sequence Diagram: Start-up / Initialisierung}
  \label{fig:seq_startup}
\end{figure}

Die Abbildung \ref{fig:seq_startup} zeigt das
Verhalten des \emph{Emergency Stop}-Subsystems während des Start-up-Prozesses.
Der \emph{System State Manager} durchläuft die Initialisierungsphase, in der die notwendigen
Handler und Schnittstellen initialisiert werden.
Jeder dieser Initialisierungsfunktionen gibt einen Fehlerstatus zurück, der überprüft wird.
Ist kein Fehler aufgetreten, wechselt der Systemzustand von "Initialization" zu "SoftStop", was den Normalbetrieb einleitet.
Tritt jedoch ein Fehler auf, wird dieser protokolliert und der Systemzustand wechselt in den "Error" Zustand.

\subsubsection{Sequence Diagram: Shutdown}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_ShutDown.png}
  \caption{Sequence Diagram: Shutdown}
  \label{fig:seq_shutdown}
\end{figure}

Die Abbildung \ref{fig:seq_shutdown} zeigt das Verhalten des \emph{Emergency Stop}-Subsystems während des Shutdown-Prozesses.
Der \emph{System State Manager} sendet zunächst eine Stop-Anforderung an die \emph{Drive Control Unit}, um das Fahrzeug sicher zum Stillstand zu bringen.
Der Shutdown-Prozess wird anschließend geloggt.
Außerdem wird die Kommunikationsschnittstelle zum \emph{Mission-Control}
sauber geschlossen, um Fehler bei der nächsten Initialisierung zu vermeiden.
Dies markiert den Abschluss des Shutdown-Prozesses.

\subsubsection{Sequence Diagram: Error Scenario}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramms/Seq_Error1.png}
  \caption{Sequence Diagram: Error Scenario (Beispiel)}
  \label{fig:seq_error}
\end{figure}

%TODO: Inkonsistente Namen für Drive Controller Handler

Die Abbildung \ref{fig:seq_error} zeigt ein Beispiel für ein Fehler-Szenario im \emph{Emergency Stop}-Subsystem.
In diesem Szenario tritt während der Anfrage vom \emph{System State Manager}
an den \emph{TTC handler} ob eine Stop-Anforderung vorliegt, ein Fehler auf.
Der \emph{TTC Handler} gibt einen Fehlerstatus zurück, der vom \emph{System State Manager} erkannt wird.
In diesem Fall wird der Systemzustand auf "Error" gesetzt, um anzuzeigen, dass ein Fehler aufgetreten ist.
Dieser stellt, entsprechend des Eintritts in den Error-Zustand, eine Stop-Anforderung an den \emph{Drive Controller Handler}.
Der Fehler wird außerdem protokolliert, um die Diagnose und Fehlerbehebung zu erleichern.